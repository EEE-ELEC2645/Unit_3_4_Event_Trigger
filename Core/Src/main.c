// ELEC2645 Event Trigger Example
// This example demonstrates how to use external interrupts to create an event-driven application on the STM32 microcontroller.
// The program toggles an LED and changes the LCD display mode in response to button presses


// STM32 HAL headers (auto-generated by STM32CubeMX)
#include "main.h"
#include "tim.h"       // Timer 2 for PWM buzzer control
#include "usart.h"     // For serial output
#include "gpio.h"      // GPIO control
#include "adc.h"       // ADC for joystick input

// AUTO-GENERATED STM32 FUNCTION PROTOTYPES - DO NOT EDIT
void SystemClock_Config(void);
void PeriphCommonClock_Config(void);

// Buzzer library
#include "Buzzer.h" // Not used but included for completeness and future expansion of the demo to include buzzer functionality
#include "PWM.h"    // For PWM control of the LED 
#include "LCD.h"  // For LCD demonstration 
#include "Joystick.h" // include the Joystick driver functions

#include <stdint.h>
#include <stdio.h>

// ===== BUZZER CONFIGURATION =====
// Configure buzzer to use TIM2 Channel 3 (current hardware setup)
Buzzer_cfg_t buzzer_cfg = {
    .htim = &htim2,
    .channel = TIM_CHANNEL_3,
    .tick_freq_hz = 1000000,  // 1MHz timer clock (prescaler = 79 with 80MHz input)
    .min_freq_hz = 20,
    .max_freq_hz = 20000,
    .setup_done = 0
};

// ===== LCD CONFIGURATION =====
ST7789V2_cfg_t cfg0 = {
    .setup_done = 0,
    .spi = SPI2,
    .RST = {.port = GPIOB, .pin = GPIO_PIN_2},
    .BL = {.port = GPIOB, .pin = GPIO_PIN_1},
    .DC = {.port = GPIOB, .pin = GPIO_PIN_11},
    .CS = {.port = GPIOB, .pin = GPIO_PIN_12},
    .MOSI = {.port = GPIOB, .pin = GPIO_PIN_15},
    .SCLK = {.port = GPIOB, .pin = GPIO_PIN_13},
    .dma = {.instance = DMA1, .channel = DMA1_Channel5}
};

// ===== JOYSTICK CONFIGURATION =====
Joystick_cfg_t joystick_cfg = {
    .adc = &hadc1,
    .x_channel = ADC_CHANNEL_1, //A5 on Nucleo board
    .y_channel = ADC_CHANNEL_2, //A4 on Nucleo board
    .sampling_time = ADC_SAMPLETIME_47CYCLES_5,
    .center_x = JOYSTICK_DEFAULT_CENTER_X,
    .center_y = JOYSTICK_DEFAULT_CENTER_Y,
    .deadzone = JOYSTICK_DEADZONE,
    .setup_done = 0
};

// Joystick data structure to hold readings
Joystick_t joystick_data;

// ===== PWM CONFIGURATION =====
// Configure PWM to use TIM4 Channel 1 (current hardware setup)
PWM_cfg_t pwm_cfg = {
    .htim = &htim4,
    .channel = TIM_CHANNEL_1,
    .tick_freq_hz = 1000000,  // 1MHz timer clock (prescaler = 79 with 80MHz input)
    .min_freq_hz = 10,
    .max_freq_hz = 50000,
    .setup_done = 0
};

// ===== UTILITY FUNCTIONS =====

/**
 * @brief Redirect printf to UART for debugging
 */
int _write(int file, char *ptr, int len) {
    HAL_UART_Transmit(&huart2, (uint8_t*)ptr, len, HAL_MAX_DELAY);
    return len;
}

// ===== Interrupt Variables =====

// Volatile variable to track LED state (0 = OFF, 1 = ON)
volatile uint8_t led_state = 0;

// Volatile variable to track LCD mode state (0 = normal, 1 = inverse)
volatile uint8_t lcd_mode = 0;

// Debounce delay in milliseconds
// Currently set at quite an aggressive debounce to ensure clean button presses, 
// can be adjusted based on user preference and button characteristics
// The onboard blue button has an capacitor to clean up the signal, so a shorter debounce may work fine (e.g. 50ms)
// But the button on the joystick module is quite noisy and may require a longer debounce (e.g. 200ms) to prevent multiple toggles from a single press
#define DEBOUNCE_DELAY 200

// ===== Main Function =====

/**
  * @brief  The application entry point - Event driven LED demo
  * @retval int
  */
int main(void)
{
    /* MCU Configuration */
    HAL_Init();
    SystemClock_Config();
    PeriphCommonClock_Config();

    /* Initialize peripherals */
    MX_GPIO_Init();
    MX_USART2_UART_Init();
    // Initialize LCD first (this sets up GPIOB pins)
    LCD_init(&cfg0);

    // Initialize TIM4 and TIM2 AFTER LCD to avoid GPIO conflict on PB6
    MX_TIM4_Init();
    //MX_TIM2_Init();  // Timer 2 for buzzer PWM uncomment if you want to use the buzzer in this demo
  
    // make screen black (0 in palette set in LCD.h)
    LCD_Fill_Buffer(0);

    LCD_Refresh(&cfg0);

    LCD_printString("Event",  0, 10, 1, 5);
    LCD_Refresh(&cfg0);
    HAL_Delay(200);
    LCD_printString("Driven",  0, 70, 1, 5);
    LCD_Refresh(&cfg0);
    HAL_Delay(200);
    LCD_printString("Intrrpt",  0, 140, 1, 5);
    LCD_Refresh(&cfg0);
    HAL_Delay(1000);

    LCD_Fill_Buffer(0);
    LCD_printString("Hit",  0, 10, 1, 5);
    LCD_printString("Those",  0, 70, 1, 5);
    LCD_printString("Buttons",  0, 140, 1, 5);
    LCD_Refresh(&cfg0);

    // Initialize PWM for LED control
    PWM_Init(&pwm_cfg);
    PWM_SetFreq(&pwm_cfg, 1000);  // 1kHz PWM frequency
    PWM_SetDuty(&pwm_cfg, 0);     // Start with LED OFF
    
    // Ensure LD2 on PA5 starts OFF
    HAL_GPIO_WritePin(GPIOA, GPIO_PIN_5, GPIO_PIN_RESET);

    printf("System initialized. Waiting for button press...\n");

    while (1)
    {
        // Wait for interrupts (button press) to toggle LED
        // This puts the CPU into a low-power state until an interrupt occurs
        // Peripherals (GPIO, ADC etc.) are still running
        __WFI();
    }
}

// ===== Interrupt Callback =====

/**
  * @brief EXTI line detection callback
  * @param GPIO_Pin: Specifies the pins connected EXTI line
  * 
  * @note This function is called automatically by the STM32 HAL whenever ANY external 
  *       interrupt (GPIO button press) occurs. We must check which specific button was 
  *       pressed using if statements to determine the appropriate action:
  *       - If BTN2_Pin triggered → toggle LED
  *       - If BTN3_Pin triggered → toggle LCD mode and onboard LD2
  *       This allows multiple buttons to share the same interrupt callback handler.
  */
void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
{
  static uint32_t btn2_last_interrupt_time = 0;
  static uint32_t btn3_last_interrupt_time = 0;
  uint32_t current_time = HAL_GetTick();
  
  if (GPIO_Pin == BTN2_Pin)
  {
    // Debouncing: ignore interrupts within DEBOUNCE_DELAY ms
    if ((current_time - btn2_last_interrupt_time) > DEBOUNCE_DELAY)
    {
      btn2_last_interrupt_time = current_time;
      
      // Toggle LED state
      led_state = !led_state;
      
      // Set LED using PWM library
      if (led_state)
      {
        PWM_SetDuty(&pwm_cfg, 100);  // Full brightness
      }
      else
      {
        PWM_SetDuty(&pwm_cfg, 0);    // Off
      }
    }
  }
  
  if (GPIO_Pin == BTN3_Pin)
  {
    // Debouncing: ignore interrupts within DEBOUNCE_DELAY ms
    if ((current_time - btn3_last_interrupt_time) > DEBOUNCE_DELAY)
    {
      btn3_last_interrupt_time = current_time;
      
      // Toggle LCD mode state
      lcd_mode = !lcd_mode;
      
      // Set LCD mode based on state
      if (lcd_mode)
      {
        LCD_inverseMode(&cfg0);
        HAL_GPIO_WritePin(LD2_GPIO_Port, LD2_Pin, GPIO_PIN_SET);
      }
      else
      {
        LCD_normalMode(&cfg0);
        HAL_GPIO_WritePin(LD2_GPIO_Port, LD2_Pin, GPIO_PIN_RESET);
      }
    }
  }
}

// ==== AUTO-GENERATED STM32 FUNCTIONS ====
// DO NOT EDIT UNLESS YOU KNOW WHAT YOU ARE DOING! 


/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};

  /** Configure the main internal regulator output voltage
  */
  if (HAL_PWREx_ControlVoltageScaling(PWR_REGULATOR_VOLTAGE_SCALE1) != HAL_OK)
  {
    Error_Handler();
  }

  /** Initializes the RCC Oscillators according to the specified parameters
  * in the RCC_OscInitTypeDef structure.
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
  RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
  RCC_OscInitStruct.PLL.PLLM = 1;
  RCC_OscInitStruct.PLL.PLLN = 10;
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV7;
  RCC_OscInitStruct.PLL.PLLQ = RCC_PLLQ_DIV2;
  RCC_OscInitStruct.PLL.PLLR = RCC_PLLR_DIV2;
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
  {
    Error_Handler();
  }

  /** Initializes the CPU, AHB and APB buses clocks
  */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_4) != HAL_OK)
  {
    Error_Handler();
  }
}

/**
  * @brief Peripherals Common Clock Configuration
  * @retval None
  */
void PeriphCommonClock_Config(void)
{
  RCC_PeriphCLKInitTypeDef PeriphClkInit = {0};

  /** Initializes the peripherals clock
  */
  PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_RNG|RCC_PERIPHCLK_ADC;
  PeriphClkInit.AdcClockSelection = RCC_ADCCLKSOURCE_PLLSAI1;
  PeriphClkInit.RngClockSelection = RCC_RNGCLKSOURCE_PLLSAI1;
  PeriphClkInit.PLLSAI1.PLLSAI1Source = RCC_PLLSOURCE_HSI;
  PeriphClkInit.PLLSAI1.PLLSAI1M = 1;
  PeriphClkInit.PLLSAI1.PLLSAI1N = 8;
  PeriphClkInit.PLLSAI1.PLLSAI1P = RCC_PLLP_DIV7;
  PeriphClkInit.PLLSAI1.PLLSAI1Q = RCC_PLLQ_DIV4;
  PeriphClkInit.PLLSAI1.PLLSAI1R = RCC_PLLR_DIV2;
  PeriphClkInit.PLLSAI1.PLLSAI1ClockOut = RCC_PLLSAI1_48M2CLK|RCC_PLLSAI1_ADC1CLK;
  if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
  {
    Error_Handler();
  }
}



/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();
  while (1)
  {
  }
  /* USER CODE END Error_Handler_Debug */
}
#ifdef USE_FULL_ASSERT
/**
  * @brief  Reports the name of the source file and the source line number
  *         where the assert_param error has occurred.
  * @param  file: pointer to the source file name
  * @param  line: assert_param error line source number
  * @retval None
  */
void assert_failed(uint8_t *file, uint32_t line)
{
  /* USER CODE BEGIN 6 */
  /* User can add his own implementation to report the file name and line number,
     ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
  /* USER CODE END 6 */
}
#endif /* USE_FULL_ASSERT */
